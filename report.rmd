---
title: "Written Report"
output: 
  html_document:
    toc: true
    toc_float: true
    code_folding: hide
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  warning = FALSE,
  message = FALSE,
  dev.args = list(bg = "transparent")
  )
```

```{r}
library(tidyverse)
library(plotly)
library(knitr)
library(lubridate)
library(ggcorrplot)
library(plotly)


steam_theme <- theme_classic() + 
  theme(
    panel.background = element_rect(fill = "transparent", color = NA), 
    plot.background = element_rect(fill = "transparent", color = NA),
    legend.background = element_rect(fill = "transparent", color = NA),
    legend.box.background = element_rect(fill = "transparent", color = NA),
    text = element_text(color = "#66c0f4")
    )

theme_set(steam_theme)
```

# Motivation

Video game industry is a highly competitive market where thousands of new products are released annually. For developers, understanding the specific factors that drive player engagement is important when allocating their resources. For players facing an overwhelming number of choices, identifying games that align with their interests is a challenge. This project is motivated by both the need to bridge this gap and our enthusiasm towards gaming: by analyzing real-world data from [Steam](https://en.wikipedia.org/wiki/Steam_(service)), we aim to build a predictive model that can estimate a game's popularity based on pre-release information.

# Related Work

Our work is inspired by the recent kick-off of [TGA](https://thegameawards.com/nominees/game-of-the-year): An once-a-year celebration of game developers and players, simply consider it as the Oscar of gaming industry.

# Initial Questions

Our major questions is: **What are the primary drivers of game popularity on Steam?**

As we explored the dataset, this question evolved into more specific hypotheses:
"Does a higher price point correlate with higher quality and thus more playtime?" "Is the relationship between price and engagement non-linear, perhaps differing for Indie vs. AAA titles?"
"Do critical reviews (Metacritic) serve as a better predictor of peak concurrent users than user reviews?"
"Can the number of DLCs act as a proxy for a game's longevity?"

# Data

## Data Source

The dataset used for this project is made possible by [FronkonGames](https://fronkongames.github.io/) and is sourced at [huggingface.co](https://huggingface.co/datasets/FronkonGames/steam-games-dataset).

## Scraping

The author provides an official python script to scrape this dataset, it can be viewed [here]("data/scrapping.py"). Additionally, we did some sampling 
from local. The chunk below converted a dataframe of 110000 rows to 10629 rows to pass Github's file uploading size. It is not meant to be ran.
```{r}
# df = read_csv("steam_games.csv") |>
#   filter(!is.na(average_playtime),
#          !is.na(peak_ccu),
#          !is.na(median_playtime))

# write_csv(df, "steam_games.csv")
```

## Cleaning

During the cleaning process, our pipeline aims to:

-Make sure variable names are consistent across columns

-Select only the unique identifier and necessary variables for our popularity analysis

-Make sure continuous variables are numeric

-Make sure `release_date` is in date format

-Convert the `estimated_owners` from a range to a numeric value by taking the midpoint

-Make sure no zeros or NAs are present in `average_playtime`, `median_playtime` and `peak_ccu` as they are meaningless in these columns

```{r}
steam_df = read_csv("data/steam_games.csv") |>
  janitor::clean_names() |>
  select(
    app_id, name, release_date, price, required_age,
    estimated_owners, peak_ccu, average_playtime, median_playtime,
    achievements, dlc_count, developers, publishers,
    categories, genres, tags, positive, negative
  ) |>
  mutate(
    price = as.numeric(price),
    required_age = as.numeric(required_age),
    achievements = as.numeric(achievements),
    dlc_count = as.numeric(dlc_count),
    positive = as.numeric(positive),
    negative = as.numeric(negative),
    release_date = mdy(release_date)
  ) |>
  mutate(estimated_owners = str_extract(estimated_owners, "\\d+"),
         estimated_owners = as.numeric(estimated_owners)) |>
  filter(
    average_playtime > 0,
    median_playtime > 0,
    peak_ccu > 0
  )

```

## Key Variables

**app_id**: Unique identifier of each game

**name**: Game name on Steam

**release_date**: Official releasing time in yyyy-mm-dd

**price**: Price in USD

**estimated_owners**: Rough estimate of owners

**peak_ccu**: Peak number of online concurrent users

**average_playtime, median_playtime**: Playtime since March 2009, in minutes

**achievements**: Number of unlockable achievements 

**dlc_count**: Number of DLCs (expansion or extra chapters sold separately from the game)

**developers, publishers**: Creator of the game / Seller of the game

**categories**: Type of the game

**genres**: Theme of the game

**tags**: Tags added by users

**positive, negative**: Number of positive / negative reviews by user on Steam

# Exploratory Data Analysis

In this study, we consider both playtime and peak concurrent users to reflect a game's popularity. Let's first look at the distribution of these games.

## Popularity Distributions

```{r}
apt_distribution = steam_df |> 
  ggplot(aes(x = average_playtime)) +
  geom_histogram(bins = 50, fill = "#66c0f4") +
  scale_x_continuous(trans = "log10") +
  labs(
    title = "Distribution of Average Playtime (Log Scale)",
    x = "Average playtime (minutes)"
  )

ggplotly(apt_distribution)
```

```{r}
pccu_distribution = steam_df |>
  ggplot(aes(x = peak_ccu)) +
  geom_histogram(bins = 50, fill = "#66c0f4") +
  scale_x_continuous(trans = "log10") +
  labs(
    title = "Distribution of Peak Concurrent Users (Log Scale)",
    x = "Peak CCU"
  )

ggplotly(pccu_distribution)
```

Note that playtime and peak_ccu are both heavyly tailed (most games are barely played, and a few games dominate), so we apply a log transformation here to see a meaningful distribution and avoid outliers.

## Estimated Owners vs Popularity 

Owners represent the overall reach of a game while peak_ccu reflects active use. Games with high owner counts but low CCU may indicate weak long-term engagement.
```{r}
eo_trend = steam_df |>
  ggplot(aes(x = estimated_owners, y = peak_ccu)) +
  geom_point(alpha = 0.3, color = "#66c0f4") +
  scale_x_continuous(trans = "log10") +
  scale_y_continuous(trans = "log10") +
  labs(
    title = "Estimated Owners vs Peak CCU",
    x = "Estimated Owners",
    y = "Peak CCU"
  )

ggplotly(eo_trend)
```

## Release Time Trends

```{r}
rt_trend = steam_df |>
  ggplot(aes(x = release_date, y = average_playtime)) +
  geom_point(alpha = 0.3, color = "#66c0f4") +
  geom_smooth(se = FALSE, color = "#e6e9f0") +
  scale_y_continuous(trans = "log10") +
  labs(
    title = "Engagement Patterns by Release Year",
    y = "Average playtime"
  )

ggplotly(rt_trend)
```

## Popularity by Genre

Genres encapsulate game design choices. This identifies which genres tend to drive deeper engagement.

```{r}
genres_trend = steam_df|>
  separate_rows(genres, sep = ",") |>
  mutate(weight = estimated_owners) |>
  group_by(genres) |>
  summarize(
    weighted_playtime = weighted.mean(average_playtime, w = weight, na.rm = TRUE),
    total_owners = sum(estimated_owners, na.rm = TRUE),
    n_games = n()
  ) |>
  arrange(desc(weighted_playtime)) |>
  slice_head(n = 20) |>
  ggplot(aes(x = reorder(genres, weighted_playtime), 
             y = weighted_playtime)) +
  geom_col() +
  coord_flip() +
  labs(
    title = "Top Genres by Weighted Average Playtime",
    x = "Genre",
    y = "Weighted Mean Playtime (minutes)"
  )

ggplotly(genres_trend)
```

## Review Ratio vs Popularity

Reviews reflect user satisfaction. If higher satisfaction correlates with higher playtime, review sentiment becomes a strong candidate predictor.

```{r}
rr_trend = steam_df |>
  mutate(review_ratio = positive / (positive + negative)) |>
  ggplot(aes(x = review_ratio, y = average_playtime)) +
  geom_point(alpha = 0.3) +
  scale_y_continuous(trans = "log10") +
  labs(
    title = "Review Sentiment vs Playtime",
    x = "Positive Review Ratio",
    y = "Average playtime (log10)"
  )

ggplotly(rr_trend)
```


## Correlation

Lastly, we use a correlation graph to check for potential predictors for our model.

```{r}
correlation = steam_df |>
  select(price, required_age, estimated_owners, 
         peak_ccu, average_playtime, median_playtime,
         achievements, dlc_count, positive, negative) |>
  cor(use = "complete.obs") |>
  ggcorrplot(lab = TRUE, ggtheme = steam_theme)

ggplotly(correlation)
```

# Additional Analysis



# Conclusion and Findings
